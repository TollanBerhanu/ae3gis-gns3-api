#!/usr/bin/env python3
import requests
from dataclasses import dataclass
from typing import Any, Dict, List, Tuple
from urllib.parse import urlparse

from core.template_cache import TemplateCacheError, load_registry
from models import APISettings

# ========= Edit these lines =========
API_BASE = "http://127.0.0.1:8000"
BUILD_URL = f"{API_BASE}/scenario/build"
SCRIPTS_URL = f"{API_BASE}/scripts/push"

PROJECT_NAME = "ae3gis-root-2"

# Provide overrides for each GNS3 server you want to target. Leave fields blank to fall back to defaults
# discovered from the FastAPI cache / settings.
TARGET_GNS3_SERVERS: List[Dict[str, Any]] = [
    {
        # "label": "primary-lab",
        # "ip": "10.193.80.120",
        # "port": 3080,
        # "username": "gns3",
        # "password": "gns3",
        # "base_url": "http://10.193.80.120:3080",
    },
]
# ========= ================== =========


# How many scenarios (tiles) to create and how they are laid out
NUM_SCENARIOS = 9
SCENARIOS_PER_ROW = 3             # how many tiles per row
TILE_WIDTH = 900                  # px between scenarios horizontally
TILE_HEIGHT = 500                 # px between scenarios vertically
CANVAS_TOP_LEFT = (-500, -400)  # where the first scenario starts

# Clients layout inside each scenario (tile)
CLIENTS_PER_SCENARIO = 13
CLIENTS_PER_ROW = 13
NODE_SPACING_X = 50
NODE_SPACING_Y = 50

# Special node offsets inside a tile (relative to tile origin)
SWITCH_OFFSET = (300, -140)
DHCP_OFFSET = (600, -140)
SERVER_OFFSET = (300, -250)

# Scripts (local to your machine)
SERVER_SCRIPT = "./run_server.sh"
DHCP_SCRIPT = "./run_dhcp.sh"
CLIENT_SCRIPT = "./run_http.sh"
SCRIPTS_CONCURRENCY = 13  # the API may still run uploads concurrently; our calls remain sequential

ID_PAD = 2  # zero pad for names like 01, 02, ...
START_AT = 1
# ===========================================

# Template IDs (resolved from cache generated by the FastAPI service)
_settings = APISettings()  # type: ignore[call-arg]

try:
    _registry = load_registry(_settings.templates_cache_path)
except TemplateCacheError as exc:
    raise SystemExit(
        f"{exc}\nStart the FastAPI service once so it can populate the template cache."
    ) from exc

_template_raw = _registry.get("templates")
if not isinstance(_template_raw, dict):
    raise SystemExit(
        "Template cache is missing the 'templates' mapping. "
        "Start the FastAPI service to refresh the cache."
    )

_template_source: Dict[str, str] = {
    str(name): str(identifier)
    for name, identifier in _template_raw.items()
    if isinstance(name, str) and isinstance(identifier, str)
}

_project_source = _registry.get("projects") or {}
_projects_cache = {
    str(name): str(identifier)
    for name, identifier in getattr(_project_source, "items", lambda: [])()
    if isinstance(name, str) and isinstance(identifier, str)
}

if PROJECT_NAME not in _projects_cache:
    available_projects = ", ".join(sorted(_projects_cache)) or "<none>"
    raise SystemExit(
        "Project not found in cache: "
        + PROJECT_NAME
        + f". Available projects: {available_projects}."
        + "\nStart the FastAPI service to refresh the cache or update PROJECT_NAME."
    )

PROJECT_ID = _projects_cache[PROJECT_NAME]

_server_info = _registry.get("server") or {}
DEFAULT_GNS3_BASE_URL = str(_server_info.get("base_url") or _settings.gns3_base_url).rstrip("/")
DEFAULT_GNS3_SERVER_IP = str(_server_info.get("ip") or _settings.gns3_server_ip)

if not DEFAULT_GNS3_BASE_URL:
    raise SystemExit(
        "Unable to determine GNS3 base URL from cache or settings. "
        "Set GNS3_BASE_URL in the environment or refresh the cache."
    )

_parsed_default_url = urlparse(
    DEFAULT_GNS3_BASE_URL if "://" in DEFAULT_GNS3_BASE_URL else f"http://{DEFAULT_GNS3_BASE_URL}"
)
DEFAULT_GNS3_SCHEME = _parsed_default_url.scheme or "http"
DEFAULT_GNS3_HOST = _parsed_default_url.hostname or DEFAULT_GNS3_SERVER_IP
DEFAULT_GNS3_PORT = _parsed_default_url.port
DEFAULT_GNS3_PORT_IN_URL = _parsed_default_url.port is not None
DEFAULT_GNS3_BASE_URL = (
    f"{DEFAULT_GNS3_SCHEME}://{DEFAULT_GNS3_HOST}{f':{DEFAULT_GNS3_PORT}' if DEFAULT_GNS3_PORT_IN_URL else ''}"
).rstrip("/")

DEFAULT_GNS3_USERNAME = "gns3"
DEFAULT_GNS3_PASSWORD = "gns3"

REQUIRED_TEMPLATE_NAMES: Tuple[str, ...] = (
    "test-client:v0.2",
    "nginx-server:v0.2",
    "open-v-switch:v0.3",
    "isc-dhcp-server:v0.5",
)


def _resolve_templates(required: Tuple[str, ...]) -> Dict[str, str]:
    missing = [name for name in required if name not in _template_source]
    if missing:
        available = ", ".join(sorted(_template_source)) or "<none>"
        raise SystemExit(
            "Missing templates in cache: "
            + ", ".join(missing)
            + f". Available templates: {available}."
            + "\nStart the FastAPI service to refresh the cache."
        )
    return {name: _template_source[name] for name in required}


TEMPLATES: Dict[str, str] = _resolve_templates(REQUIRED_TEMPLATE_NAMES)


@dataclass
class Tile:
    col: int
    row: int
    x: int
    y: int


@dataclass
class ServerConfig:
    label: str
    base_url: str
    server_ip: str
    username: str
    password: str


def _normalize_target_entry(entry: Dict[str, Any] | None, index: int) -> ServerConfig:
    data = entry or {}

    username = str(data.get("username") or DEFAULT_GNS3_USERNAME)
    password = str(data.get("password") or DEFAULT_GNS3_PASSWORD)

    raw_base_url = str(data.get("base_url") or "").strip()
    raw_ip = str(data.get("ip") or "").strip()
    raw_scheme = str(data.get("scheme") or "").strip()
    raw_label = str(data.get("label") or data.get("name") or "").strip()
    raw_port = data.get("port")

    if raw_base_url:
        parsed = urlparse(
            raw_base_url if "://" in raw_base_url else f"{DEFAULT_GNS3_SCHEME}://{raw_base_url}"
        )
        scheme = parsed.scheme or raw_scheme or DEFAULT_GNS3_SCHEME
        host = parsed.hostname or raw_ip or DEFAULT_GNS3_HOST
        port = parsed.port if parsed.port is not None else None
    else:
        scheme = raw_scheme or DEFAULT_GNS3_SCHEME
        host = raw_ip or DEFAULT_GNS3_HOST
        port = None

    if raw_port not in (None, ""):
        try:
            port = int(raw_port)
        except (TypeError, ValueError) as exc:
            raise SystemExit(f"Invalid port for target #{index}: {raw_port}") from exc
    elif port is None and DEFAULT_GNS3_PORT_IN_URL:
        port = DEFAULT_GNS3_PORT

    if not host:
        host = DEFAULT_GNS3_HOST

    if port is not None:
        base_url = f"{scheme}://{host}:{port}"
    else:
        base_url = f"{scheme}://{host}"

    ip_value = raw_ip or host or DEFAULT_GNS3_SERVER_IP
    label = raw_label or ip_value or f"target-{index}"

    return ServerConfig(
        label=label,
        base_url=base_url.rstrip("/"),
        server_ip=ip_value,
        username=username,
        password=password,
    )


def resolve_target_servers(raw_targets: List[Dict[str, Any]]) -> List[ServerConfig]:
    entries = raw_targets or [{}]
    configs: List[ServerConfig] = []
    for idx, entry in enumerate(entries, start=1):
        configs.append(_normalize_target_entry(entry, idx))
    return configs


def tile_for_index(idx: int) -> Tile:
    col = idx % SCENARIOS_PER_ROW
    row = idx // SCENARIOS_PER_ROW
    x = CANVAS_TOP_LEFT[0] + col * TILE_WIDTH
    y = CANVAS_TOP_LEFT[1] + row * TILE_HEIGHT
    return Tile(col, row, x, y)


def make_clients(tile: Tile, start_id: int) -> Tuple[List[Dict], List[str], int]:
    nodes = []
    names = []
    next_id = start_id
    for i in range(CLIENTS_PER_SCENARIO):
        r = i // CLIENTS_PER_ROW
        c = i % CLIENTS_PER_ROW
        x = tile.x + c * NODE_SPACING_X
        y = tile.y + r * NODE_SPACING_Y
        name = f"Client-{next_id:0{ID_PAD}d}"
        nodes.append({
            "name": name,
            "template_id": TEMPLATES["test-client:v0.2"],
            "x": x,
            "y": y
        })
        names.append(name)
        next_id += 1
    return nodes, names, next_id


def make_special_nodes(tile: Tile, scenario_idx: int) -> Tuple[List[Dict], Dict[str, str]]:
    sid = scenario_idx + START_AT
    sw_name = f"OpenvSwitch-{sid:0{ID_PAD}d}"
    dhcp_name = f"DHCP-{sid:0{ID_PAD}d}"
    server_name = f"Server-{sid:0{ID_PAD}d}"
    sx, sy = SWITCH_OFFSET
    dx, dy = DHCP_OFFSET
    vx, vy = SERVER_OFFSET

    nodes = [
        {"name": sw_name, "template_id": TEMPLATES["open-v-switch:v0.3"], "x": tile.x + sx, "y": tile.y + sy},
        {"name": dhcp_name, "template_id": TEMPLATES["isc-dhcp-server:v0.5"], "x": tile.x + dx, "y": tile.y + dy},
        {"name": server_name, "template_id": TEMPLATES["nginx-server:v0.2"], "x": tile.x + vx, "y": tile.y + vy},
    ]
    return nodes, {"switch": sw_name, "dhcp": dhcp_name, "server": server_name}


def make_links(client_names: List[str], switch_name: str, dhcp_name: str, server_name: str) -> List[Dict]:
    links = []
    # clients to switch (client adapter 0 -> switch adapters 1..n)
    for i, cname in enumerate(client_names, start=1):
        links.append({
            "nodes": [
                {"node_id": cname, "adapter_number": 0, "port_number": 0},
                {"node_id": switch_name, "adapter_number": i, "port_number": 0},
            ]
        })
    # server to switch (next adapter)
    next_adapter = len(client_names) + 1
    links.append({
        "nodes": [
            {"node_id": server_name, "adapter_number": 0, "port_number": 0},
            {"node_id": switch_name, "adapter_number": next_adapter, "port_number": 0},
        ]
    })
    # dhcp to switch (next adapter)
    links.append({
        "nodes": [
            {"node_id": dhcp_name, "adapter_number": 0, "port_number": 0},
            {"node_id": switch_name, "adapter_number": next_adapter + 1, "port_number": 0},
        ]
    })
    return links


def build_payload(
    tile: Tile,
    scenario_idx: int,
    next_client_id: int,
    server: ServerConfig,
) -> Tuple[Dict, List[str], Dict[str, str], int]:
    client_nodes, client_names, after_id = make_clients(tile, next_client_id)
    special_nodes, special_names = make_special_nodes(tile, scenario_idx)
    links = make_links(client_names, special_names["switch"], special_names["dhcp"], special_names["server"])

    payload = {
        "base_url": server.base_url,
        "start_nodes": True,
        "username": server.username,
        "password": server.password,
        "scenario": {
            "gns3_server_ip": server.server_ip,
            "project_name": PROJECT_NAME,
            "project_id": PROJECT_ID,
            "templates": TEMPLATES,  # do not repeat IDs elsewhere
            "nodes": client_nodes + special_nodes,
            "links": links,
        }
    }
    return payload, client_names, special_names, after_id


def post_json(url: str, data: Dict) -> Dict:
    r = requests.post(url, json=data, timeout=360)
    r.raise_for_status()
    return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"text": r.text}


def push_script(
	node_name: str,
	local_path: str,
	remote_path: str,
	server: ServerConfig,
	shell: str = "sh",
	timeout: int = 10,
) -> None:
    payload = {
        "scripts": [{
            "node_name": node_name,
            "local_path": local_path,
            "remote_path": remote_path,
            "run_after_upload": True,
            "executable": True,
            "overwrite": True,
            "run_timeout": timeout,
            "shell": shell
        }],
        "gns3_server_ip": server.server_ip,
        "concurrency": SCRIPTS_CONCURRENCY,
        "username": server.username,
        "password": server.password,
    }
    post_json(SCRIPTS_URL, payload)


def push_batch_scripts(
	node_names: List[str],
	local_path: str,
	remote_path: str,
	server: ServerConfig,
	shell: str = "sh",
	timeout: int = 10,
) -> None:
    scripts = [{
        "node_name": n,
        "local_path": local_path,
        "remote_path": remote_path,
        "run_after_upload": True,
        "executable": True,
        "overwrite": True,
        "run_timeout": timeout,
        "shell": shell
    } for n in node_names]
    payload = {
        "scripts": scripts,
        "gns3_server_ip": server.server_ip,
        "concurrency": SCRIPTS_CONCURRENCY,
        "username": server.username,
        "password": server.password,
    }
    post_json(SCRIPTS_URL, payload)


def main():
    next_client_id = START_AT
    servers = resolve_target_servers(TARGET_GNS3_SERVERS)

    with requests.Session() as _:
        for server in servers:
            print(f"\n=== Targeting GNS3 server: {server.label} ({server.base_url}) ===")
            for scenario_idx in range(NUM_SCENARIOS):
                tile = tile_for_index(scenario_idx)
                build_body, client_names, special_names, next_client_id = build_payload(
                    tile,
                    scenario_idx,
                    next_client_id,
                    server,
                )

                print(
                    f"Building scenario {scenario_idx + 1}/{NUM_SCENARIOS}"
                    f" at tile ({tile.col},{tile.row}) origin=({tile.x},{tile.y})"
                )
                post_json(BUILD_URL, build_body)

                # Sequential script pushes (order matters)
                print("  Pushing server script...")
                push_script(special_names["server"], SERVER_SCRIPT, "/usr/local/bin/run_server.sh", server)
                print("  Pushing DHCP script...")
                push_script(special_names["dhcp"], DHCP_SCRIPT, "/usr/local/bin/run_dhcp.sh", server)
                print("  Pushing client scripts...")
                push_batch_scripts(client_names, CLIENT_SCRIPT, "/usr/local/bin/run_http2.sh", server)

    print("Done.")


if __name__ == "__main__":
    main()